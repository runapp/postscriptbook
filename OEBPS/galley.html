<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Galley Proofs</title>
    <link rel="stylesheet" type="text/css" href="postscript.css" />
  </head>
  <body>
    <h1><a name="gallery">Galley Proofs</a></h1>

    <div class="navbar">
      <a href="postscript.html">Main Page</a>
      &bull;
      <a href="nup.html">Next Page</a>
    </div>

    <p>A galley proof is a printout of a document in which the margins are
      especially large. The idea is that you can read over what you have printed
      and have room for writing comments. This system was important in the days
      of manuscripts and lead-cast type, because the layout of your document
      was under the control of the publisher&rsquo;s typesetter. You would receive
      a galley proof from your publisher and make comments about mistakes or
      changes to be made. </p>

    <p>When you have control of the typesetting, galley proofs are not so important,
      but you may still want to have them. Many systems will not let you make
      a galley proof, but fortunately it is not hard to do.</p>

    <p>The main idea is that you want to scale each page down (to make room
      for the extra big margins) and then translate the document up and to the
      right.</p>

    <p>Let us say that we want to give ourselves an extra inch of margin on
      the vertical margins (and scale the horizontals to keep the proportions
      correct). Here is the PostScript code to do that:</p>

<pre>
        gsave
          8.5 6.5 sub 2 div inch               % Center page horizontally...
          11 11 6.5 8.5 div mul sub 2 div inch %  and vertically
          translate
          6.5 8.5 div               % Scale page horizontally...
          dup                       %  and vertically
          scale
          % original page code here...
        grestore
</pre>

    <p>Here is a slightly faster version. Here, we allow the post-processor
      to do the math for us. This will print more quickly, since each page does
      not need to do its own division.</p>

<pre>
        gsave
          72 93 translate
          .7647 .7647 scale
          % original page code here...
        grestore
</pre>

    <p>Why the <a href="operators.html#gsave">gsave</a> and
      <a href="operators.html#grestore">grestore</a>?
      Well, a good rule of thumb is to <em>always</em> save the graphics state
      before you go about changing it (and remember to restore it when you are
      done). Also, one of the rules of the document structuring convention is
      that each page should restore the state of the system to what it was when
      the page was about to start. In other words, the code to layout a page
      should not alter the permanent state of the system (graphics or otherwise).
      This assures that pages can be reordered after the PostScript has been
      generated.</p>

    <h2><a name="hard">The Hard Part</a></h2>

    <p>The hard part of all of this is knowing <em>where</em> to insert the new
      code. Where does one page begin and another end? You could look for calls
      to <a href="operators.html#showpage">showpage</a>, but many programs define
      their own versions of this operator (in the code that is generated by <code>dvips</code>,
      for instance, it is called <code>eop</code>).</p>

    <p>So, how <em>do</em> we go about recognizing pages? The document structuring
      conventions provide us with some handy comments for flagging page information.
      The most important is the <b>%%Page:</b> comment. This comment specifies
      that the next piece of code is the first one for the new page (in fact,
      it also tells you which page it is). The end of the document should also
      be marked with a <b>%%Trailer:</b> comment and a <b>%%EOF</b> comment.
      The <b>%%Trailer:</b> comment specifies that code to be run at the end
      of the document is about to be given (so, we are done with the pages).
      The <b>%%EOF</b> comment specifies that we are done with the file. Again,
      this specifies that we have processed the last page.</p>

    <p>So, using these comments, how can we add the needed PostScript? Well,
      we can start by looking for the first <b>%%Page:</b> comment. When we find
      it, we insert the translate and scale commands right after it. Thereafter,
      we will proceed each <b>%%Page:</b> with a grestore and insert the translate
      and scale code after the comment. This process continues until we find
      either a <b>%%Trailer:</b> or a <b>%%EOF</b> comment. The first of these
      we find is proceeded by a grestore.</p>

    <p>This is all we need to do. To make things a bit more concrete, here
      is a PERL script to do the job (to make things a bit more interesting,
      I have added a light line around the original page&rsquo;s image, so you can
      know how big it is):</p>

<pre>
#!/usr/local/bin/perl
$flag = 0;
while (&lt;&gt;) {
    if (/^%%Page:/) {
        if ($flag) {
            print &quot;grestore\n&quot;;
        }
        $flag = 1;
        print $_;
        print &quot;gsave 72 93 translate .7647 .7647 scale\n&quot;;
        print &quot;gsave .75 setgray newpath -1 -1 moveto 614 0 rlineto\n&quot;;
        print &quot;0 794 rlineto -614 0 rlineto closepath stroke grestore\n&quot;;
    } elsif (/^%%Trail/) {
        if ($flag) {
            print &quot;grestore\n&quot;;
        }
        print $_;
        $flag = 0;
    } elsif (/^%%EOF/) {
        if ($flag) {
            print &quot;grestore\n&quot;;
        }
        print $_;
        $flag = 0;
    } else {
        print;
    }
}
</pre>

    <p>Now, this script is not perfect. Many PostScript files do not conform
      as they should. This script can, however, serve as a starting point for
      your own, more robust code.</p>

    <div class="navbar">
      <a href="postscript.html">Main Page</a>
      &bull;
      <a href="nup.html">Next Page</a>
    </div>
  </body>
</html>
